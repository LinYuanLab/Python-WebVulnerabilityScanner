#Imports
import stem.process, datetime, urlparse, socket, thread, Queue, socks, time, sys, os
from PyQt4 import QtGui,QtCore,QtWebKit,QtNetwork
from BeautifulSoup import BeautifulSoup

class MainWindow(QtGui.QMainWindow):
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        self.setWindowState(QtCore.Qt.WindowMaximized)
        self.setWindowTitle("BlackScanner")
        self.setWindowIcon(QtGui.QIcon('icons/eye.ico'))

        #Application Configuration
        QtCore.QCoreApplication.setApplicationName("BlackScanner")
        QtCore.QCoreApplication.setApplicationVersion("0.4")
        QtCore.QCoreApplication.setOrganizationName("BlackSecurity")
        QtCore.QCoreApplication.setOrganizationDomain("")

        #A Simple Function To Get The Current Time According to Your Computer Clock
        self.getTime = lambda: str(datetime.datetime.now()).split(" ")[-1].split(".")[0]
        
        #Toolbar
        self.toolbar = self.addToolBar("")
        self.toolbar.setMovable(False)
        self.toolbar.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)
        self.toolbar.setOrientation(QtCore.Qt.Horizontal)

        #Status Bar
        self.statusBar = self.statusBar()
        self.statusBar.setFixedHeight(30)

        #"New Scan" Button
        self.new_scan_btn = QtGui.QPushButton(QtGui.QIcon("icons/eye.ico"), 'New Scan', self)
        self.new_scan_btn.clicked.connect(self.newScan)
        self.toolbar.addWidget(self.new_scan_btn)

        #Main Splitter
        self.main_splitter = QtGui.QSplitter(self)
        self.main_splitter.setOrientation(QtCore.Qt.Vertical)

        #Main Layout
        main_layout = QtGui.QVBoxLayout(self)
        main_layout.setMargin(0)
        main_layout.addWidget(self.main_splitter)
        self.setCentralWidget(self.main_splitter)

        #Secondary Splitter
        self.secondary_splitter = QtGui.QSplitter(self)
        self.secondary_splitter.setOrientation(QtCore.Qt.Horizontal)
        self.main_splitter.addWidget(self.secondary_splitter)

        #Toolbox Tree View
        self.tools_tree = QtGui.QTreeView()
        self.tools_tree.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)

        self.model = QtGui.QStandardItemModel()
        self.model.setHorizontalHeaderLabels(['Tools'])
        
        self.model.appendRow( QtGui.QStandardItem(QtGui.QIcon('icons/eye.ico'), "New Scan" ) )
        
        self.tools_tree.setModel(self.model)
        self.tools_tree.setUniformRowHeights(True)

        self.tools_tree.connect(self.tools_tree, QtCore.SIGNAL('clicked(QModelIndex)'), self.tool_selected)

        self.secondary_splitter.addWidget(self.tools_tree)
        
        #Scanner Tree View
        self.scanner_tree = QtGui.QTreeView()
        self.scanner_tree.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
        self.scanner_tree.setSortingEnabled(False)
        self.scanner_tree.setAlternatingRowColors(True)
        self.scanner_tree.setUniformRowHeights(True)
        self.scanner_tree.setGeometry(0, 0, 800, 500)
        
        self.model_2 = QtGui.QStandardItemModel(0, 1, self)
        self.model_2.setHorizontalHeaderLabels(['File Path', 'Status'])
        self.scanner_tree.setModel(self.model_2)
        self.scanner_tree.setColumnWidth(0, 350)

        self.secondary_splitter.addWidget(self.scanner_tree)

        #An Empty Item That is Going To Be Used Later
        self.empty_item = QtGui.QStandardItem("")
        self.empty_item.setEditable(False)

        #Errors, Warnings, Alerts and Messages Logger
        self.logs = QtGui.QTextEdit()
        self.logs.setReadOnly(True)
        self.logs.setFontFamily("Fixedsys")
        self.logs.setMaximumHeight(120)
        self.logs.setFontWeight(10)
        self.main_splitter.addWidget(self.logs)

        #Setup Page Preview
        self.setupWebView("http://www.google.com/")


    #Start a New Scan
    def newScan(self):
        #Show Input Dialog Box Asking For Website URL
        text, ok = QtGui.QInputDialog.getText(self, 'New Scan', 'Website URL:')

        if ok:
            if str(text).lower().startswith("http"):
                #Define A Few Variables
                self.target = str(text).replace("http://", "").replace("https://", "").split("/")[0]
                self.queue = Queue.Queue()
                self.isSQLiVuln = False
                self.checkedParams = []

                #Appends a Empty Row to The TreeView
                if self.model_2.rowCount() >= 1:
                    self.model_2.appendRow( [self.empty_item, self.empty_item])

                if self.target.endswith(".onion"):
                    self.connectToTorNetwork()

                #Add a New Main Parent Into Tree For a New Scan
                self.current_scan_thread = QtGui.QStandardItem(QtGui.QIcon('icons/eye.ico'), "Scan Results For: {}".format(self.target))
                self.current_scan_thread.setEditable(False)
                self.model_2.appendRow( [self.current_scan_thread, self.empty_item])

                #Add Web Alerts Row On Main Parent To Show Vulnerability Alerts etc ...
                self.vulnScan = QtGui.QStandardItem(QtGui.QIcon('icons/earth_alert.ico'), "Web Alerts" )
                self.vulnScan.setEditable(False)
                self.current_scan_thread.appendRow( [self.vulnScan, self.empty_item])

                #Start a New Thread For The Port Scanner
                thread.start_new_thread( self.portScan, () )
                #Start a New Thread For The Crawler
                thread.start_new_thread( self.crawlLinks, (str(text),) )

                #thread.start_new_thread( self.checkSQLi, ( str(text), ) )
            else:
                #Show Critical Error Dialog Box Saying That URL is Invalid or Unreachable
                QtGui.QMessageBox.critical(QtGui.QWidget(), "Invalid URL", "{}\nThe URL That You Provided Is Invalid Or Unreachable.".format(str(text)))

    def connectToTorNetwork(self, tor_socks_port=9150):
        try:
            tor_process = stem.stem.process.launch_tor_with_config(
                config = {
                    'SocksPort': str(tor_socks_port),
                }, init_msg_handler = self.print_bootstrap_lines)
            self.logMessage("\n")
        except OSError:
            self.logWarning("[{}] Tor Seems To Be Alredy Running. Skipping Initialization ...\n\n".format(self.getTime()))
        except Exception as e:
            sys.exit(e)

        try:
            socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, "127.0.0.1", tor_socks_port)
            socket.socket = socks.socksocket
            socket.getaddrinfo = self.getaddrinfo
            socket.create_connection = self.create_connection
        except Exception as e:
            sys.exit(e)

    def print_bootstrap_lines(self, line):
        if "Bootstrapped " in line:
            self.logMessage("[{}] Bootstrapped {}\n".format(self.getTime(), line.split("Bootstrapped ")[1]))

    def create_connection(self, address, timeout=None, source_address=None):
        sock = socks.socksocket()
        sock.connect(address)
        return sock

    def getaddrinfo(self, *args):
        return [(socket.AF_INET, socket.SOCK_STREAM, 6, '', (args[0], args[1]))]

    #Scan URL For SQL Injection Vulnerabilities
    def checkSQLi(self, url):
        import urllib2
        #List of Payloads To Test
        payloads = ['-1', '\\', '\\\\', '=1', "1'", "'1", '1=1', '+-', '-+', '-a*b', 'a*1', 'a*b', '1*9', ',,', "'", "=1\' or \'1\' = \'1\'", "a=b"]
        #URL is Vulnerable ?
        vuln = False

        #List of Commom Errors In Databases That Shows That The URL is Vulnerable
        errors = ["You have an error in your SQL syntax", "error in your SQL syntax", "access shop category information",
                  "Supplied argument is not a valid MySQL result resource in", "Microsoft OLE DB Provider for Oracle", "Warning: require()",
                  "SQL Error", "SQLServer JDBC Driver", "Error Executing Database Query", "Microsoft OLE DB for SQL Server", "Unclosed quotation mark",
                  "ODBC Microsoft Access Driver", "Microsoft JET Database", "XPATH syntax error", "Warning:", "MySQL error:"]

        #Loops Through All Payloads in The Payloads List
        for pload in payloads:
            try:
                #Gets The Source Code of The Given URL
                source = urllib2.urlopen(url+pload).read().decode('utf-8')
                #Gets The Last Parameter Found on The URL To Test
                parameter = url.split("/")[-1].split("=")
                #Deletes The Parameter Value
                del parameter[-1]

                #Loops Through All Error Messages in The Errors List
                for error in errors:
                    if error in source:
                        #Checks if Host Alredy is Vulnerable To SQLi, if Not:
                        if self.isSQLiVuln == False:
                            #Create New Row To Store SQLi Vulnerable Parameters Values
                            self.sql_ = QtGui.QStandardItem(QtGui.QIcon('icons/alert.ico'), "SQL Injection" )
                            self.sql_.setEditable(False)
                            self.vulnScan.appendRow( [self.sql_, self.empty_item])
                            #This Host is Now Vulnerable, We Don't Need to Get Into This Statement Again
                            self.isSQLiVuln = True

                        #Checks if This URL is Vulnerable and If The Parameter Being Checked Haven't Been Checked Yet
                        if vuln == False and parameter[-1].split("?")[0] not in self.checkedParams:
                            #Now This URL is Vulnerable, So, We Don't Need to Get Into This Statement on it Again
                            vuln = True
                            #Create New Row With The Parameter That is Being Checked Name
                            self.checkedParams.append(parameter[-1].split("?")[0])
                            self.param = QtGui.QStandardItem(QtGui.QIcon('icons/info.ico'), parameter[-1].split("?")[0] )
                            self.param.setEditable(False)
                            self.sql_.appendRow( [self.param, self.empty_item])
                        #If URL is Vulnerable
                        elif vuln == True:
                            #Append The Tested Payload To The Checked Payloads List and To The Parent Parameter Row
                            b = QtGui.QStandardItem(QtGui.QIcon('icons/file_blank.ico'), "{}={}".format(parameter[-1].split("?")[-1], pload) )
                            b.setEditable(False)
                            self.param.appendRow( [b, self.empty_item])
                    else:
                        pass
            #If Catch Any Error
            except Exception as e:
                #Logs The Error on The Log Console
                self.logError("[{}] {}.\n".format(self.getTime(), e))

    #Start Port Scanner
    def portScan(self):
        #Logs a Message in The Log Console
        self.logMessage("[{}] Starting Port Scanner ...\n".format(self.getTime()))

        #Create a Parent Row To Store The Port Scanner Results
        self.port_scanner = QtGui.QStandardItem(QtGui.QIcon('icons/cog.ico'), "Port Scanner Results")
        self.port_scanner.setEditable(False)
        self.current_scan_thread.appendRow( [self.port_scanner, self.empty_item])

        #Creates 100 Threads For The Port Scanner
        for x in range(100):
             thread.start_new_thread( self.portScan_thread, () )

        #Scan Only Ports Between 1 And 1024
        for worker in range(0, 1025):
            self.queue.put(worker)

        #Wait Until Finish Scanning All Ports
        self.queue.join()

    #Thread To Be Called By The portScan Function
    def portScan_thread(self):
        while True:
            worker = self.queue.get()
            test = self.checkPort(worker)
            self.queue.task_done()

    #Check The Target Port State And Returns Open or Filtered
    def checkPort(self, port):
        #Create The Socket Object To Handle Connections
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        #Sorts All Items On The Port Scanner Results Row
        self.port_scanner.sortChildren(1)
        try:
            #Connect To The Target Host:Port
            con = sock.connect((self.target, port))

            #Creates a New Row And Append it To The Port Scanner Results With State: Open
            p = QtGui.QStandardItem(QtGui.QIcon('icons/cog.ico'), str(port))
            p.setEditable(False)
            s = QtGui.QStandardItem("Open")
            s.setEditable(False)
            self.port_scanner.appendRow( [p, s] )
            con.close()
        #If Target Host:Port Take Too Long To Reply:
        except socket.timeout:
            #Creates a New Row And Append it To The Port Scanner Results With State: Filtered
            p = QtGui.QStandardItem(QtGui.QIcon('icons/cog.ico'), str(port))
            p.setEditable(False)
            s = QtGui.QStandardItem("Filtered")
            s.setEditable(False)
            self.port_scanner.appendRow( [p, s] )
        except:
            pass

    #Check if URL its a File
    def isMime(self, input):
        MIME_TYPE = ('',)
        for type in MIME_TYPE:
            if type == input:return True
        return False

    #Check if URL is URL
    def isUrl(self, input):
        URL_TYPE = ('.html', '.htm', '.php', '.asp', '.aspx', '.shtml', '')
        for type in URL_TYPE:
            if type == input:return True
        return False

    #Start Crawler
    def crawlLinks(self, url):
        import urllib2
        #Define Some Variables
        crawl_history = []
        url_queue = Queue.Queue()
        url_queue.put(url)
        target = url.replace("http://", "").replace("https://", "").split("/")[0]
        checked_links = []
        
        icon_list = ['php', 'html', 'css', 'bmp', 'png', 'jpg', 'gif', 'doc', 'dmg', 'xml', 'zip', 'rar', 'mp3', 'pdf', 'txt', 'dll', 'exe', 'ini', 'mov', 'wav']

        #Logs a "Starting Crawler" Message on The Log Console
        self.logMessage("[{}] Starting Crawler ...\n".format(self.getTime()))

        #Create New Row To Store Results Returned By Crawler
        parent = QtGui.QStandardItem(QtGui.QIcon('icons/file_blank.ico'), "Crawling Results")
        parent.setEditable(False)
        self.current_scan_thread.appendRow( [parent, self.empty_item])

        #Loops Infinitely
        while True:
            #If URL Queue Doesn't Have Any Other URL To Crawl:
            if url_queue.empty():
                #Exit Loop
                break
            #Else:
            else:
                #Get URL From URL Queue
                cur_url = url_queue.get()

                #If "?" or "=" in The URL That is Being Crawled:
                if "?" in cur_url and "=" in cur_url:
                    #Checks if URL is Vulnerable to SQLi
                    thread.start_new_thread( self.checkSQLi, (cur_url,) )
                try:
                    #Get The Response, Status And Source From The URL That Being Crawled
                    response = urllib2.urlopen(cur_url)
                    status = QtGui.QStandardItem("{} {}".format(response.code, response.msg) )
                    source   = response.read()
                    try:
                        #Gets All Tags From URL Source
                        soup = BeautifulSoup(source)
                        tags = soup('a')

                        #Loop Through All Tags in The Tags List
                        for tag in tags:
                            #Gets a href Tag ...
                            href = tag.get('href')
                            href = urlparse.urljoin(url, href)

                            href_path = urlparse.urlparse(href).path
                            ext = os.path.splitext(href_path)[1]

                            if href in crawl_history:
                                continue

                            #If URL on The href is a Valid URL, is From The Same Site That is Being Scanned And its Not in The Crawl History:
                            if self.isUrl(ext) and href.replace("http://", "").replace("https://", "").split("/")[0] == target and href not in crawl_history:
                                #Appends URL To The Crawl_History and To URL Queue
                                crawl_history.append(href)
                                url_queue.put(href)

                                #Gets URL Location on Target Site
                                loc = href.replace("http://", "").replace("https://", "").replace(href.replace("http://", "").replace("https://", "").split("/")[0], "")

                                #Loops Through The Icon List
                                for icon in icon_list:
                                    #If Href Location is Not in The Checked Links List:
                                    if loc not in checked_links:
                                        #If Found Any . in The Location String
                                        if "." in loc:
                                            #Splits The Location String By The . And Compares if its Value its The Same of Any Icon on The Icon List
                                            if loc.split(".")[-1] == icon:
                                                #Appends a New Row With The Location Name And Specific Icon To The Crawler Tree
                                                c = QtGui.QStandardItem(QtGui.QIcon('icons/file_{}.ico'.format(icon)), loc)
                                                c.setEditable(False)
                                                parent.appendRow( [c, status] )
                                                #Expands The Entire Main Tree
                                                self.scanner_tree.expandAll()
                                                #Append Location To Checked Links List
                                                checked_links.append(loc)
                                                #Sorts All Rows in The Crawler Tree By Name
                                                parent.sortChildren(0)
                                            #Same As Above, But, if The Location is Something Like random.php#Test We Still Can Get its File Type
                                            elif loc.split(".")[-1].startswith(icon):
                                                #Appends a New Row With The Location Name And Specific Icon To The Crawler Tree
                                                c = QtGui.QStandardItem(QtGui.QIcon('icons/file_{}.ico'.format(icon)), loc)
                                                c.setEditable(False)
                                                parent.appendRow( [c, status] )
                                                self.scanner_tree.expandAll()
                                                checked_links.append(loc)
                                                parent.sortChildren(0)
                                        #Else:
                                        else:
                                            #Appends a New Row With The Location Name And With a Folder Icon To The Crawler Tree ...
                                            c = QtGui.QStandardItem(QtGui.QIcon('icons/folder.ico'), loc)
                                            c.setEditable(False)
                                            parent.appendRow( [c, status] )
                                            self.scanner_tree.expandAll()
                                            checked_links.append(loc)
                                            parent.sortChildren(0)
                    except Exception as e:
                        #Log Any Error Into Log Console
                        self.logError("[{}] {}.\n".format(self.getTime(), e))
                except Exception as e:
                    #Log Any Error Into Log Console
                    self.logError("[{}] {}.\n".format(self.getTime(), e))

        #Logs Finished Crawling Website Message Into The Log Console
        self.logMessage("[{}] Finished Crawling Website.\n".format(self.getTime()))

    #Function To Setup The Page Preview WebView
    def setupWebView(self, url):
        #Create a New Webview
        self.webView = QtWebKit.QWebView()

        #Configures it To Use Javascript, Enable Plugins, Dev Tools Etc ...
        for setting in (QtWebKit.QWebSettings.globalSettings().PluginsEnabled, QtWebKit.QWebSettings.globalSettings().JavaEnabled,
                        QtWebKit.QWebSettings.globalSettings().JavascriptEnabled, QtWebKit.QWebSettings.globalSettings().AutoLoadImages,
                        QtWebKit.QWebSettings.globalSettings().DeveloperExtrasEnabled, QtWebKit.QWebSettings.globalSettings().AcceleratedCompositingEnabled,
                        QtWebKit.QWebSettings.globalSettings().DnsPrefetchEnabled, QtWebKit.QWebSettings.globalSettings().LocalContentCanAccessFileUrls,
                        QtWebKit.QWebSettings.globalSettings().LocalContentCanAccessRemoteUrls, QtWebKit.QWebSettings.globalSettings().OfflineWebApplicationCacheEnabled,
                        QtWebKit.QWebSettings.globalSettings().JavascriptCanOpenWindows, QtWebKit.QWebSettings.globalSettings().JavascriptCanAccessClipboard,
                        QtWebKit.QWebSettings.globalSettings().OfflineWebApplicationCacheEnabled, QtWebKit.QWebSettings.globalSettings().WebGLEnabled,
                        QtWebKit.QWebSettings.globalSettings().PrivateBrowsingEnabled):
            QtWebKit.QWebSettings.globalSettings().setAttribute(setting, True)

        #Splits The Page Preview In 2 Parts And Adds The WebView in The First Part
        self.web_view_splitter = QtGui.QSplitter(self)
        self.web_view_splitter.setOrientation(QtCore.Qt.Vertical)
        self.secondary_splitter.addWidget(self.web_view_splitter)
        self.web_view_splitter.addWidget(self.webView)

        #Creates a Web Inspector From The WebView And Puts It in The Other Part of The Splitter
        self.webInspector = QtWebKit.QWebInspector(self)
        self.webInspector.setPage(self.webView.page())
        self.webInspector.setVisible(True)
        self.web_view_splitter.addWidget(self.webInspector)

        #Load Main Page
        self.webView.load(QtCore.QUrl( url ))

    #Log a Message on The Log Console
    def logMessage(self, message):
        self.logs.setTextColor(QtGui.QColor(0, 0, 0))
        self.logs.insertPlainText(message)

    #Log a Error on The Log Console
    def logError(self, message):
        self.logs.setTextColor(QtGui.QColor(255, 0, 0))
        self.logs.insertPlainText(message)

    #Log a Warning on The Log Console
    def logWarning(self, message):
        self.logs.setTextColor(QtGui.QColor(255, 200, 0))
        self.logs.insertPlainText(message)

    #Handle Single Click Event on The Tools on Toolbox TreeView
    def tool_selected(self, index):
        item = index.model().itemFromIndex(index)
        if str(item.text()) == "New Scan":
            self.newScan()
        else:
            pass


if __name__ == "__main__":
    app=QtGui.QApplication(sys.argv)
    window=MainWindow()
    window.show()
    sys.exit(app.exec_())
